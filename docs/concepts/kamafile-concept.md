---
sidebar_label: Kamafile
sidebar_position: 3
---

# The Kamafile

When the NMachine client installs an application for a user (e.g creates _an_ NMachine), 
it begins by creating a `ConfigMap` called `kamafile` in the application's
namespace. This is where the installation's identity and state are stored. Note, as 
per **[our stance on stack pollution](/concepts/principles#zero-tolerance-for-stack-pollution)**, 
that this `ConfigMap` is the only mandatory parcel of pollution that an NMachine must _must_ introduce
into the user's stack.    




## Kamafile Schema

All the identity and state information we care about is stored in key-value format 
under the `data` field of the `ConfigMap`. Inside of `data`, each outermost key corresponds to 
a **[`space`](/concepts/spaces-concept.md)**. The value of each such key is a long JSON string that encodes 
_the actual_ identity and state for that space. Greater detail on the 
**[Space Partitioning](#space-partitioning)** follows.


### Example Kamafile

The typical kamafile has the following shape:

```yaml title="$ kubectl get kamafile -o json"
kind: ConfigMap
metadata:
  name: "kamafile"
  namespace: "xyz"
  labels:
    managed_by: "nmachine"  
data:
  app: '{
    "install_id": "xxx",
    "install_token: "yyy",
    "status": "installing",
    "ktea": {"type": "x", "uri": "y", "version": "z"},
    "kama": {"type": "x", "uri": "y", "version": "z"},
    "default_vars": {"x": "y"},
    "injection_vars": {"y": "z"},	
    "user_vars": {},
    "last_synced": "2021-07-21 14:23:54.731164"
  }'
  "some.plugin": '{
    #...more of the same
  }'
```

### Attributes Table

The table below gives the purpose of each field in a space entry.

| Key                   | Purpose                                                                                             |
|-----------------------|-----------------------------------------------------------------------------------------------------|
| `install_id`          | UUID for this particular installation, generated by `api.nmachine.io`                               |
| `install_token`       | Authentication token for this particular install against `api.nmachine.io`                          |
| `ktea`                | Definition bundle for the current KTEA detailed **[below](#ktea-dict-format)** |
| `kama`                | Definition bundle for the current KAMA detailed **[below](#kama-dict-format)** |
| `status`              | Last computed status for this space: `running`, `broken` or `installing`                            |
| `default_vars`   | Level zero of manifest variables, detailed **[below](#manifest-variablesr)**                           |
| `publisher_injection_vars`   | Level one of manifest variables, detailed **[below](#manifest-variables)**                           |
| `user_injection_vars`   | Level two of manifest variables, detailed **[below](#manifest-variables)**                           |
| `user_vars`   | Level three of manifest variables, detailed **[below](#manifest-variables)**                           |
| `last_synced`         | Timestamp of last successful status/telem sync with `api.nmachine.io`                               |




### `ktea` & `kama` Dict Formats

The `ktea` and `kama` entries are themselves Dict. They share the same schema: 

{@import ./../../partials/ktea-dict.md}






## Space Partitioning





## Manifest Variables

NMachine groups manifest variables into **four levels**. When an NMachine needs to 
invoke its **[KTEA's](/concepts/ktea-concept)** templating function, it **deep merges 
the four levels** to produce final bundle for the KTEA.  The four levels are:

1. **`default_vars`**. An immutable copy of the variables from **[KTEA's](/concepts/ktea-concept)**
`GET /values`. Obtained once when the NMachine installs and cached in the kamafile to avoid redundant KTEA invokations.

1. **`publisher_injection_vars`**. Assignments defined by the _publisher_ via the 
**[Publisher Dashboard](https://publish.nmachine.io)** on behalf of the user; typically
plan or region specific settings or secrets. Pulled from `api.nmachine.io`.

1. **`user_injection_vars`**. Assignment defined by the user via the
**[User Dashboard](https://an.nmachine.io)**. Essentially `user_vars` that users can save to the cloud, 
guaranteeing persistence if one NMachine dies. Pulled from `api.nmachine.io`.

1. **`user_vars`**. Assignments made by the user while operating their NMachine via the client app/site.  

    
The diagram below summarizes the manifest variable lifecycle by level:

![](/img/concepts/variables-lifecycle.png)


### Accessing Manifest Variables

You will typically use pre-built **[Suppliers](/prebuilt-models/suppliers/suppliers-overview)** and 
**[Actions](/prebuilt-models/actions/actions-overview)**, 
as well as the  **[`ManifestVariable` Model](/prebuilt-models/variables/manifest-variables)** to interact with
the kamafile's manifest variables. While debugging, however, it can be helpful to know how to read/write variables
directly with the `kamafile` API:

```python title="$ python main.py console"

```

Find the full API in the **[Python docs](https://kama-sdk-py.readthedocs.io/en/latest/)**.




## Access with the KAMA SDK

The KAMA SDK
provides a programmatic interface to deal with it: a singleton instance of 
`ConfigMan` called `config_man`. The instance can be imported and used as follows:

```python
from kama_sdk.core.core.config_man import config_man
print(config_man.install_id())
```

**In most cases however,** you will not need to call the `config_man`
directly; you should instead use the many specialized Models such as 
[`Supplier`](/models/supplier/supplier-base), 
[`Action`](/models/actions/action-base), and 
[`ManifestVariable`](/models/actions/action-base)
to achieve specific goals. For instance, to check the 
manifest variable `ingress.enabled`
 is truthy, there's `MergedVariablesSupplier` for that: 
```yaml title="my-models.yaml"
kind: SomeOuterModel
#...
is_ingress_enabled: 
  kind: Predicate
  operator: truthiness
  challenge: get::kind::MergedVariablesSupplier->.ingress.enabled
```





