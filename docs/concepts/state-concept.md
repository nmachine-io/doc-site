---
sidebar_label: Kamafile
sidebar_position: 3
---

# The Kamafile

When the NMachine client installs an application for a user (e.g creates _an_ NMachine), 
it begins by creating a `ConfigMap` called `kamafile` in the application's
namespace. This is where the installation's identity and state are stored.  

## Format

All data is stored in key-value format inside the `data` field of the 
`ConfigMap`. 
Each outermost key is the name of a `space` in the KAMA. If you haven't read up on
[Spaces and Plugins](/concepts/spaces-concept.md) yet, the Space system 
exists to let an application KAMA have mini-KAMAs inside it, each with its
own state and variables. 

Thus, the value of each `space` key is that space's state, encoded as large JSON string.
A fresh Kamafile would look something like the following:

```yaml title="<install namespace>/<configmaps>/master"
kind: ConfigMap
metadata:
  name: kamafile
  namespace: xyz
  labels:
    managed_by: nmachine  
data:
  app: '{
    "install_id": "xxx",
    "install_token: "yyy",
    "status": "installing",
    "ktea": {"type": "x", "uri": "y", "version": "z"},
    "kama": {"type": "x", "uri": "y", "version": "z"},
    "default_variables": {"x": "y"},
    "injection_variables": {"y": "z"},	
    "user_variables": {},
    "last_synced": "2021-07-21 14:23:54.731164"
  }'
  "some.plugin": '{
    #...more of the same
  }'
```

## Contents

The table below gives the purpose of each field in a space entry.

| Key                   | Purpose                                                                                             |
|-----------------------|-----------------------------------------------------------------------------------------------------|
| `install_id`          | UUID for this particular installation, generated by `api.nmachine.io`                               |
| `install_token`       | Authentication token for this particular install against `api.nmachine.io`                          |
| `ktea`                | Definition bundle for the current KTEA detailed [below](#ktea-dict-format) |
| `kama`                | Definition bundle for the current KAMA detailed [below](#kama-dict-format) |
| `status`              | Last computed status for this space: `running`, `broken` or `installing`                            |
| `default_variables`   | Variable assignments pulled from KTEA during installation or last update.                           |
| `injection_variables` | Variable assignments pulled from `api.nmachine.io` during "last mile" sync                          |
| `user_variables`      | Variable assignments made by the user with the NMachine client                                      |
| `last_synced`         | Timestamp of last successful status/telem sync with `api.nmachine.io`                               |




### `ktea` & `kama` Dict Formats

The `ktea` and `kama` entries are themselves Dict. They share the same schema: 

{@import ./../../partials/ktea-dict.md}





## Manifest Variables

NMachine has three levels of manifest variables:

1. **`default_vars`**: analogous to a virgin `values.yaml` in Helm 
1. **`injection_vars`**: pulled from `api.nmachine.io`; lets the publisher do customization remotely
1. **`user_vars`**: assignments created by the user while using the platform  

When it is time to template the manifest, **the three levels are merged** 
from top to bottom to create the final bundle. In the diagram below,
the final bundle would be:
```yaml
foo: def_foo
bar: inj_bar
baz: usr_bar
```  

The diagram below summarizes the lifecycle of the three variable levels.

![](/img/concepts/variables-lifecycle.png)


While building your KAMA, you should not write to the `default_vars` or
`injection_vars`; this is taken care of by the SDK.  






## Access with the KAMA SDK

The KAMA SDK
provides a programmatic interface to deal with it: a singleton instance of 
`ConfigMan` called `config_man`. The instance can be imported and used as follows:

```python
from kama_sdk.core.core.config_man import config_man
print(config_man.install_id())
```

**In most cases however,** you will not need to call the `config_man`
directly; you should instead use the many specialized Models such as 
[`Supplier`](/models/supplier/supplier-base), 
[`Action`](/models/actions/action-base), and 
[`ManifestVariable`](/models/actions/action-base)
to achieve specific goals. For instance, to check the 
manifest variable `ingress.enabled`
 is truthy, there's `MergedVariablesSupplier` for that: 
```yaml title="my-models.yaml"
kind: SomeOuterModel
#...
is_ingress_enabled: 
  kind: Predicate
  operator: truthiness
  challenge: get::kind::MergedVariablesSupplier->.ingress.enabled
```





